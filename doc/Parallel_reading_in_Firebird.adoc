[[parallel-reading]]
= Параллельное чтение данных в СУБД Firebird
Симонов Денис
v1.0 от 03.12.2023
:doctype: book
:sectnums!:
:sectanchors:
:experimental:
:lang: ru
:imagesdir: images
ifdef::backend-pdf[]
:pdf-fontsdir: theme/fonts
:pdf-themesdir: theme/firebird-pdf
:pdf-theme: firebird
:source-highlighter: coderay
endif::[]
ifdef::backend-html5[]
:stylesdir: theme/firebird-html
:stylesheet: firebird.css
:source-highlighter: highlight.js
endif::[]

[dedication%notitle]
--
Этот материал был создан при поддержке и спонсорстве компании https://www.ibase.ru[iBase.ru], которая разрабатывает  инструменты Firebird SQL для предприятий и предоставляет сервис технической поддержки для Firebird SQL.

Материал выпущен под лицензией Public Documentation License https://www.firebirdsql.org/file/documentation/html/en/licenses/pdl/public-documentation-license.html
--

[preface]
== Предисловие

В Firebird 5.0 появилась возможность использовать параллелизм при создании резервной копии с помощью утилиты `gbak`. 
Надо отметить, что первоначально эта функция появилась в HQbird 2.5, и уже после обкатке её реальными заказчиками была портирована в Firebird 5.0.

В этой статье мы познакомимся с некоторыми механизмами, которые используется при параллельном создании резервных копий внутри утилиты `gbak`,
а также покажем как их можно использовать в ваших приложениях для параллельного чтения данных.

Важно отметить, что здесь идёт речь не о параллельном сканировании таблиц внутри движка Firebird при выполнении SQL запросов, а чтении данных внутри вашего приложения
параллельными потоками.

Для демонстрации параллельного чтения данных из СУБД Firebird я написал простенькую утилиту, которые экспортирует данные из одной или нескольких таблиц в формат CSV.
Её описание и сходный код можно найти по адресу https://github.com/IBSurgeon/FBCSVExport.git

== Организация параллельного чтения

И так, давайте подумаем как читать данные из нескольких таблиц параллельно. Для начала надо отметить, что Firebird, позволяет выполнять запросы параллельно только если каждый из запросов будет выполняться в отдельном соединении. 

Для этой цели необходимо сделать пул рабочих потоков. Основной поток приложения
также является рабочим потоком, поэтому количество дополнительных рабочих потоков должно быть равно N - 1, где N - количество параллельных обработчиков. Каждый рабочий поток будет работать с собственным соединением и транзакцией.

И тут возникает первая проблема, а как обеспечить согласованность прочитанных данных? 

=== Согласованное чтение данных

Поскольку каждый рабочий поток использует собственное соединение и собственную транзакцию, то возникает проблема несогласованного чтения - если таблица параллельно меняется, то прочитанные данные могут быть несогласованными. В однопоточном режиме `gbak` использовал транзакцию с режимом изолированности SNAPSHOT, что позволяло читать согласованную информацию, на начало старта SNAPSHOT транзакции. Но здесь у нас несколько транзакций и необходимо, чтобы они видели один и тот же "снимок", для того чтобы они читали одни и те же неизменные данные.

Механизм создания общего снимка для разных транзакций с режимом изолированности SNAPSHOT появился в Firebird 4.0 (первоначально HQBird 2.5, но в Firebird 4.0/HQBird 4.0 он более простая и эффективная). Для создания общего снимка существует два способа:

1. Через SQL.
  - получаем номер моментального снимка из первой транзакции, например из транзакции с которой работает основной рабочий поток.
+  
[source,sql]
----
SELECT RDB$GET_CONTEXT('SYSTEM', 'SNAPSHOT_NUMBER') FROM RDB$DATABASE
----
  
  - стартуем другие транзакции запросом:
+
[source,sql]
----
SET TRANSACTION SNAPSHOT AT NUMBER snapshot_number
----
+
   где `snapshot_number` номер моментального снимка.

2. Через API.
  - 