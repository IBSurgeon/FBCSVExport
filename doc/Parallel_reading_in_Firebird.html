<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Симонов Денис, Влад Хорсун">
<title>Параллельное чтение данных в СУБД Firebird</title>
<style>
@import url(https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Noto+Serif:400,400italic,700,700italic|Droid+Sans+Mono:400,700);
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden], template { display: none; }
script { display: none !important; }
html { font-family: sans-serif;  -ms-text-size-adjust: 100%;  -webkit-text-size-adjust: 100%;  }
body { margin: 0; }
a { background: transparent; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0;  padding: 0;  }
button, input, select, textarea { font-family: inherit;  font-size: 100%;  margin: 0;  }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button;  cursor: pointer;  }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box;  padding: 0;  }
input[type="search"] { -webkit-appearance: textfield;  -moz-box-sizing: content-box; -webkit-box-sizing: content-box;  box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto;  vertical-align: top;  }
table { border-collapse: collapse; border-spacing: 0; }
meta.foundation-mq-small { font-family: "only screen and (min-width: 768px)"; width: 768px; }
meta.foundation-mq-medium { font-family: "only screen and (min-width:1280px)"; width: 1280px; }
meta.foundation-mq-large { font-family: "only screen and (min-width:1440px)"; width: 1440px; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: rgba(0, 0, 0, 0.8); padding: 0; margin: 0; font-family: "Noto Serif", "DejaVu Serif", serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
object, svg { display: inline-block; vertical-align: middle; }
.center { margin-left: auto; margin-right: auto; }
.stretch { width: 100%; }
p.lead { font-size: 1.21875em; line-height: 1.6; }
.subheader, .admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { line-height: 1.45; color: rgba(0, 0, 0, 0.85); font-weight: normal; margin-top: 0; margin-bottom: 0.25em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, h7, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #2156a5; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #1d4b8f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, h7 { font-family: "Open Sans", "DejaVu Sans", sans-serif; font-weight: bold; font-style: normal; color: rgba(0, 0, 0, 0.85); text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.0125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small, h7 small { font-size: 60%; color: rgba(77, 77, 77, 0.85); line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6, h7 { font-size: 1em; }
hr { border: solid #dddddf; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; font-weight: normal; color: rgba(0, 0, 0, 0.9); }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul.no-bullet, ol.no-bullet { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em;  }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: rgba(0, 0, 0, 0.8); border-bottom: 1px dotted #ddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #ddd; }
blockquote cite { display: block; font-size: 0.9375em; color: rgba(0, 0, 0, 0.6); }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: rgba(0, 0, 0, 0.6); }
blockquote, blockquote p { line-height: 1.6; color: rgba(0, 0, 0, 0.85); }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #ddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, h7 { line-height: 1.2; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
table { background: #fff; margin-bottom: 1.25em; border: solid 1px #dedede; }
table thead, table tfoot { background: #FFEFD5; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: rgba(0, 0, 0, 0.8); }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f8f8f7; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
body { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; tab-size: 4; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, h7 { line-height: 1.2; word-spacing: -0.05em; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
:not(pre, h1, h2, h3, #toctitle, h4, h5, h6, h7, h7):not([class^=L]) > code { font-size: 0.9375em; font-style: normal !important; letter-spacing: 0; padding: 0.1em 0.5ex; word-spacing: -0.15em; line-height: 1.45; text-rendering: optimizeSpeed; word-wrap: break-word; }
:not(pre) > code.nobreak { word-wrap: normal; }
:not(pre) > code.nowrap { white-space: nowrap; }
pre { color: rgba(0, 0, 0, 0.9); font-family: "Droid Sans Mono", "DejaVu Sans Mono", "Monospace", monospace; line-height: 1.45; text-rendering: optimizeSpeed; }
pre code, pre pre { color: inherit; font-size: inherit; line-height: inherit; }
pre > code { display: block; }
pre.nowrap, pre.nowrap pre { white-space: pre; word-wrap: normal; }
em em { font-style: normal; }
strong strong { font-weight: normal; }
.keyseq { color: rgba(51, 51, 51, 0.8); }
kbd { font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace; display: inline-block; color: rgba(0, 0, 0, 0.8); font-size: 0.65em; line-height: 1.45; background-color: #f7f7f7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 0.1em white inset; margin: 0 0.15em; padding: 0.2em 0.5em; vertical-align: middle; position: relative; top: -0.1em; white-space: nowrap; }
.keyseq kbd:first-child { margin-left: 0; }
.keyseq kbd:last-child { margin-right: 0; }
.menuseq, .menuref { color: #000; }
.menuseq b:not(.caret), .menuref { font-weight: inherit; }
.menuseq { word-spacing: -0.02em; }
.menuseq b.caret { font-size: 1.25em; line-height: 0.8; }
.menuseq i.caret { font-weight: bold; text-align: center; width: 0.45em; }
b.button:before, b.button:after { position: relative; top: -1px; font-weight: normal; }
b.button:before { content: "["; padding: 0 3px 0 2px; }
b.button:after { content: "]"; padding: 0 2px 0 3px; }
p a > code:hover { color: rgba(0, 0, 0, 0.9); }
#preheader > div.fb-logo, #header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 1.25em; padding-right: 1.25em; }
#preheader > div.fb-logo:before, #preheader > div.fb-logo:after, #header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#preheader > div.fb-logo:after, #header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#content { margin-top: 1.25em; }
#content:before { content: none; }
#header > h1:first-child { color: rgba(0, 0, 0, 0.85); margin-top: 2.25rem; margin-bottom: 0; }
#header > h1:first-child + #toc { margin-top: 8px; border-top: 1px solid #dddddf; }
#header > h1:only-child, body.toc2 #header > h1:nth-last-child(2) { border-bottom: 1px solid #dddddf; padding-bottom: 8px; }
#header .details { border-bottom: 1px solid #dddddf; line-height: 1.45; padding-top: 0.25em; padding-bottom: 0.25em; padding-left: 0.25em; color: rgba(0, 0, 0, 0.6); display: -ms-flexbox; display: -webkit-flex; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; }
#header .details span:first-child { margin-left: -0.125em; }
#header .details span.email a { color: rgba(0, 0, 0, 0.85); }
#header .details br { display: none; }
#header .details br + span:before { content: "\00a0\2013\00a0"; }
#header .details br + span.author:before { content: "\00a0\22c5\00a0"; color: rgba(0, 0, 0, 0.85); }
#header .details br + span#revremark:before { content: "\00a0|\00a0"; }
#header #revnumber { text-transform: capitalize; }
#header #revnumber:after { content: "\00a0"; }
#content > h1:first-child:not([class]) { color: rgba(0, 0, 0, 0.85); border-bottom: 1px solid #dddddf; padding-bottom: 8px; margin-top: 0; padding-top: 1rem; margin-bottom: 1.25rem; }
#toc { border-bottom: 1px solid #e7e7e9; padding-bottom: 0.5em; }
#toc > ul { margin-left: 0.125em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin: 0.5em 0; }
#toc ul { font-family: "Open Sans", "DejaVu Sans", sans-serif; list-style-type: none; }
#toc li { line-height: 1.3334; margin-top: 0.3334em; }
#toc a { text-decoration: none; }
#toc a:active { text-decoration: underline; }
#toctitle { color: rgba(0, 0, 0, 0.85); font-size: 1.2em; }
@media only screen and (min-width: 768px) { #toctitle { font-size: 1.375em; }
  body.toc2 { padding-left: 15em; padding-right: 0; }
  #toc.toc2 { margin-top: 0 !important; background: #f8f8f7; position: fixed; width: 15em; left: 0; top: 0; border-right: 1px solid #e7e7e9; border-top-width: 0 !important; border-bottom-width: 0 !important; z-index: 1000; padding: 1.25em 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; margin-bottom: 0.8rem; font-size: 1.2em; }
  #toc.toc2 > ul { font-size: 0.9em; margin-bottom: 0; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 15em; }
  body.toc2.toc-right #toc.toc2 { border-right-width: 0; border-left: 1px solid #e7e7e9; left: auto; right: 0; } }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; padding-right: 0; }
  #toc.toc2 { width: 20em; }
  #toc.toc2 #toctitle { font-size: 1.375em; }
  #toc.toc2 > ul { font-size: 0.95em; }
  #toc.toc2 ul ul { padding-left: 1.25em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #e0e0dc; margin-bottom: 1.25em; padding: 1.25em; background: #f8f8f7; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#footer { max-width: 100%; background: rgba(0, 0, 0, 0.8); padding: 1.25em; }
#footer-text { color: rgba(255, 255, 255, 0.8); line-height: 1.44; }
#content { margin-bottom: 0.625em; }
.sect1 { padding-bottom: 0.625em; }
@media only screen and (min-width: 768px) { #content { margin-bottom: 1.25em; }
  .sect1 { padding-bottom: 1.25em; } }
.sect1:last-child { padding-bottom: 0; }
.sect1 + .sect1 { border-top: 1px solid #e7e7e9; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor, h7 > a.anchor { position: absolute; z-index: 1001; width: 1.5ex; margin-left: -1.5ex; display: block; text-decoration: none !important; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before, h7 > a.anchor:before { content: "\00A7"; font-size: 0.85em; display: block; padding-top: 0.1em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h7:hover > a.anchor, h6 > a.anchor:hover, h7 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link, h7 > a.link { color: rgba(0, 0, 0, 0.85); text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover, h7 > a.link:hover { color: rgba(0, 0, 0, 0.85); }
details, .audioblock, .imageblock, .literalblock, .listingblock, .stemblock, .videoblock { margin-bottom: 1.25em; }
details > summary:first-of-type { cursor: pointer; display: list-item; outline: none; margin-bottom: 0.75em; }
.admonitionblock td.content > .title, .audioblock > .title, .exampleblock > .title, .imageblock > .title, .listingblock > .title, .literalblock > .title, .stemblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, table.tableblock > .title, .verseblock > .title, .videoblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-rendering: optimizeLegibility; text-align: left; font-family: "Noto Serif", "DejaVu Serif", serif; font-size: 1.0625rem; font-style: italic; }
table.tableblock.fit-content > caption.title { white-space: nowrap; width: 0; }
.paragraph.lead > p, #preamble > .sectionbody > [class="paragraph"]:first-of-type p { font-size: 1.21875em; line-height: 1.6; color: rgba(0, 0, 0, 0.85); }
table.tableblock #preamble > .sectionbody > [class="paragraph"]:first-of-type p { font-size: inherit; }
.admonitionblock > table { border-collapse: separate; border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; font-family: "Open Sans", "DejaVu Sans", sans-serif; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddf; color: rgba(0, 0, 0, 0.6); }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #dbdbd6; margin-bottom: 1.25em; padding: 1.25em; background: #f3f3f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock > .content > .title { color: rgba(0, 0, 0, 0.85); margin-top: 0; text-align: center; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock pre, .listingblock > .content > pre { -webkit-border-radius: 4px; border-radius: 4px; word-wrap: break-word; overflow-x: auto; padding: 1em; font-size: 0.8125em; }
@media only screen and (min-width: 768px) { .literalblock pre, .listingblock > .content > pre { font-size: 0.80625em; } }
@media only screen and (min-width: 1280px) { .literalblock pre, .listingblock > .content > pre { font-size: 0.9em; } }
.literalblock pre, .listingblock > .content > pre:not(.highlight), .listingblock > .content > pre[class="highlight"], .listingblock > .content > pre[class^="highlight "] { background: #FFFFF7; }
.literalblock.output pre { color: #FFFFF7; background-color: rgba(0, 0, 0, 0.9); }
.listingblock > .content { position: relative; }
.listingblock code[data-lang]:before { display: none; content: attr(data-lang); position: absolute; font-size: 0.75em; top: 0.425rem; right: 0.5rem; line-height: 1; text-transform: uppercase; color: inherit; opacity: 0.5; }
.listingblock:hover code[data-lang]:before { display: block; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: inherit; opacity: 0.5; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: "$"; }
.listingblock pre.highlightjs { padding: 0; }
.listingblock pre.highlightjs > code { padding: 1em; -webkit-border-radius: 4px; border-radius: 4px; }
.listingblock pre.prettyprint { border-width: 0; }
.prettyprint { background: #FFFFF7; }
pre.prettyprint .linenums { line-height: 1.45; margin-left: 2em; }
pre.prettyprint li { background: none; list-style-type: inherit; padding-left: 0; }
pre.prettyprint li code[data-lang]:before { opacity: 1; }
pre.prettyprint li:not(:first-child) code[data-lang]:before { display: none; }
table.linenotable { border-collapse: separate; border: 0; margin-bottom: 0; background: none; }
table.linenotable td[class] { color: inherit; vertical-align: top; padding: 0; line-height: inherit; white-space: normal; }
table.linenotable td.code { padding-left: 0.75em; }
table.linenotable td.linenos { border-right: 1px solid currentColor; opacity: 0.35; padding-right: 0.5em; }
pre.pygments .lineno { border-right: 1px solid currentColor; opacity: 0.35; display: inline-block; margin-right: 0.75em; }
pre.pygments .lineno:before { content: ""; margin-right: -0.125em; }
.quoteblock { margin: 0 1em 1.25em 1.5em; display: table; }
.quoteblock:not(.excerpt) > .title { margin-left: -1.5em; margin-bottom: 0.75em; }
.quoteblock blockquote, .quoteblock p { color: rgba(0, 0, 0, 0.85); font-size: 1.15rem; line-height: 1.75; word-spacing: 0.1em; letter-spacing: 0; font-style: italic; text-align: justify; }
.quoteblock blockquote { margin: 0; padding: 0; border: 0; }
.quoteblock blockquote:before { content: "\201c"; float: left; font-size: 2.75em; font-weight: bold; line-height: 0.6em; margin-left: -0.6em; color: rgba(0, 0, 0, 0.85); text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: 0.75em; margin-right: 0.5ex; text-align: right; }
.verseblock { margin: 0 1em 1.25em 1em; }
.verseblock pre { font-family: "Open Sans", "DejaVu Sans", sans; font-size: 1.15rem; color: rgba(0, 0, 0, 0.85); font-weight: 300; text-rendering: optimizeLegibility; }
.verseblock pre strong { font-weight: 400; }
.verseblock .attribution { margin-top: 1.25rem; margin-left: 0.5ex; }
.quoteblock .attribution, .verseblock .attribution { font-size: 0.9375em; line-height: 1.45; font-style: italic; }
.quoteblock .attribution br, .verseblock .attribution br { display: none; }
.quoteblock .attribution cite, .verseblock .attribution cite { display: block; letter-spacing: -0.025em; color: rgba(0, 0, 0, 0.6); }
.quoteblock.abstract blockquote:before, .quoteblock.excerpt blockquote:before, .quoteblock .quoteblock blockquote:before { display: none; }
.quoteblock.abstract blockquote, .quoteblock.abstract p, .quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p { line-height: 1.6; word-spacing: 0; }
.quoteblock.abstract { margin: 0 1em 1.25em 1em; display: block; }
.quoteblock.abstract > .title { margin: 0 0 0.375em 0; font-size: 1.15em; text-align: center; }
.quoteblock.excerpt > blockquote, .quoteblock .quoteblock { padding: 0 0 0.25em 1em; border-left: 0.25em solid #dddddf; }
.quoteblock.excerpt, .quoteblock .quoteblock { margin-left: 0; }
.quoteblock.excerpt blockquote, .quoteblock.excerpt p, .quoteblock .quoteblock blockquote, .quoteblock .quoteblock p { color: inherit; font-size: 1.0625rem; }
.quoteblock.excerpt .attribution, .quoteblock .quoteblock .attribution { color: inherit; text-align: left; margin-right: 0; }
table.tableblock { max-width: 100%; border-collapse: separate; }
p.tableblock:last-child { margin-bottom: 0; }
td.tableblock > .content { margin-bottom: 1.25em; }
td.tableblock > .content > :last-child { margin-bottom: -1.25em; }
table.tableblock, th.tableblock, td.tableblock { border: 0 solid #dedede; }
table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock { border-width: 0 1px 1px 0; }
table.grid-all > tfoot > tr > .tableblock { border-width: 1px 1px 0 0; }
table.grid-cols > * > tr > .tableblock { border-width: 0 1px 0 0; }
table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock { border-width: 0 0 1px 0; }
table.grid-rows > tfoot > tr > .tableblock { border-width: 1px 0 0 0; }
table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child { border-right-width: 0; }
table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock { border-bottom-width: 0; }
table.frame-all { border-width: 1px; }
table.frame-sides { border-width: 0 1px; }
table.frame-topbot, table.frame-ends { border-width: 1px 0; }
table.stripes-all tr, table.stripes-odd tr:nth-of-type(odd), table.stripes-even tr:nth-of-type(even), table.stripes-hover tr:hover { background: #f8f8f7; }
table.stripes-none tr { background: none; }
th.halign-left, td.halign-left { text-align: left; }
th.halign-right, td.halign-right { text-align: right; }
th.halign-center, td.halign-center { text-align: center; }
th.valign-top, td.valign-top { vertical-align: top; }
th.valign-bottom, td.valign-bottom { vertical-align: bottom; }
th.valign-middle, td.valign-middle { vertical-align: middle; }
table thead th, table tfoot th { font-weight: bold; }
tbody tr th { display: table-cell; line-height: 1.6; background: #FFEFD5; }
tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p { color: rgba(0, 0, 0, 0.8); font-weight: bold; }
p.tableblock > code:only-child { background: none; padding: 0; }
p.tableblock { font-size: 1em; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
dl dt code { font-weight: bold; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.checklist, ul.none, ol.none, ul.no-bullet, ol.no-bullet, ol.unnumbered, ul.unstyled, ol.unstyled { list-style-type: none; }
ul.no-bullet, ol.no-bullet, ol.unnumbered { margin-left: 0.625em; }
ul.unstyled, ol.unstyled { margin-left: 0; }
ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > .fa-square-o:first-child, ul.checklist li > p:first-child > .fa-check-square-o:first-child { width: 1.25em; font-size: 0.8em; position: relative; bottom: 0.125em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.inline { display: -ms-flexbox; display: -webkit-box; display: flex; -ms-flex-flow: row wrap; -webkit-flex-flow: row wrap; flex-flow: row wrap; list-style: none; margin: 0 0 0.625em -1.25em; }
ul.inline > li { margin-left: 1.25em; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
.unstyled dl dt code { font-weight: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1, td.hdlist2 { vertical-align: top; padding: 0 0.625em; }
td.hdlist1 { font-weight: bold; padding-bottom: 1.25em; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist td:not([class]):first-child { padding: 0.4em 0.75em 0 0.75em; line-height: 1; vertical-align: top; }
.colist td:not([class]):first-child img { max-width: none; }
.colist td:not([class]):last-child { padding: 0.25em 0; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px #fff; -webkit-box-shadow: 0 0 0 1px #ddd; box-shadow: 0 0 0 1px #ddd; }
.imageblock.left { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; display: inline-block; }
a.image object { pointer-events: none; }
sup.footnote, sup.footnoteref { font-size: 0.875em; position: static; vertical-align: super; }
sup.footnote a, sup.footnoteref a { text-decoration: none; }
sup.footnote a:active, sup.footnoteref a:active { text-decoration: underline; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -0.25em 0 0.75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em 0 0.225em; line-height: 1.3334; font-size: 0.875em; margin-left: 1.2em; margin-bottom: 0.2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; margin-left: -1.05em; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: 0; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > .fa { cursor: default; }
a span.icon > .fa { cursor: inherit; }
.admonitionblock td.icon [class^="fa icon-"] { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #19407c; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum[data-value] { display: inline-block; color: #fff !important; background-color: rgba(0, 0, 0, 0.8); -webkit-border-radius: 50%; border-radius: 50%; text-align: center; font-size: 0.75em; width: 1.67em; height: 1.67em; line-height: 1.67em; font-family: "Open Sans", "DejaVu Sans", sans-serif; font-style: normal; font-weight: bold; }
.conum[data-value] * { color: #fff !important; }
.conum[data-value] + b { display: none; }
.conum[data-value]:after { content: attr(data-value); }
pre .conum[data-value] { position: relative; top: -0.125em; }
b.conum * { color: inherit !important; }
.conum:not([data-value]):empty { display: none; }
dt, th.tableblock, td.content, div.footnote { text-rendering: optimizeLegibility; }
h1, h2, p, td.content, span.alt { letter-spacing: -0.01em; }
h1 code, h2 code, h3 code, #toctitle code, .sidebarblock > .content > .title code, h4 code, h5 code, h6 code, h7 code, h7 code { font-size: inherit; }
p strong, td.content strong, div.footnote strong { letter-spacing: -0.005em; }
p { margin-bottom: 1.25rem; }
.sidebarblock p, .sidebarblock dt, .sidebarblock td.content, p.tableblock { font-size: 1em; }
.exampleblock > .content { background-color: #fffef7; border-color: #e0e0dc; -moz-box-shadow: 0 1px 4px #e0e0dc; -webkit-box-shadow: 0 1px 4px #e0e0dc; box-shadow: 0 1px 4px #e0e0dc; }
div.sect1, div.sect2, div.sect3, div.sect4, div.sect5, div.sect6 { margin-top: 2em; }
div#preheader > div.fb-docindex table { background-color: #f8f8f7; width: 100%; }
div#preheader table { border: none; }
#tocbot { overflow-y: auto; }
#tocbot > .toc-list { overflow: hidden; position: relative; }
#tocbot > .toc-list li { list-style: none; }
#tocbot .toc-list { margin: 0; padding-left: 10px; }
@media screen { #tocbot a.toc-link { height: 100%; }
  #tocbot .is-collapsible { max-height: 1000px; overflow: hidden; }
  #tocbot .is-collapsed { max-height: 0; }
  #tocbot .is-position-fixed { position: fixed !important; top: 0; }
  #tocbot .is-active-link { font-weight: 700; }
  #tocbot .toc-link::before { background-color: #EEE; content: ' '; display: inline-block; height: inherit; left: 0; margin-top: -1px; position: absolute; width: 2px; }
  #tocbot .is-active-link::before { background-color: #54BC4B; } }
@media print { #tocbot #tocbot a.toc-link.node-name--H4 { display: none; } }
.print-only { display: none !important; }
@page { margin: 1.25cm 0.75cm; }
@media print { * { -moz-box-shadow: none !important; -webkit-box-shadow: none !important; box-shadow: none !important; text-shadow: none !important; }
  html { font-size: 80%; }
  a { color: inherit !important; text-decoration: underline !important; }
  a.bare, a[href^="#"], a[href^="mailto:"] { text-decoration: none !important; }
  a[href^="http:"]:not(.bare):after, a[href^="https:"]:not(.bare):after { content: "(" attr(href) ")"; display: inline-block; font-size: 0.875em; padding-left: 0.25em; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  pre, blockquote, tr, img, object, svg { page-break-inside: avoid; }
  thead { display: table-header-group; }
  svg { max-width: 100%; }
  p, blockquote, dt, td.content { font-size: 1em; orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  #toc, .sidebarblock, .exampleblock > .content { background: none !important; }
  #toc { border-bottom: 1px solid #dddddf !important; padding-bottom: 0 !important; }
  body.book #header { text-align: center; }
  body.book #header > h1:first-child { border: 0 !important; margin: 2.5em 0 1em 0; }
  body.book #header .details { border: 0 !important; display: block; padding: 0 !important; }
  body.book #header .details span:first-child { margin-left: 0 !important; }
  body.book #header .details br { display: block; }
  body.book #header .details br + span:before { content: none !important; }
  body.book #toc { border: 0 !important; text-align: left !important; padding: 0 !important; margin: 0 !important; }
  body.book #toc, body.book #preamble, body.book h1.sect0, body.book .sect1 > h2 { page-break-before: always; }
  .listingblock code[data-lang]:before { display: block; }
  #footer { padding: 0 1.25em; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
@media print, amzn-kf8 { #header > h1:first-child { margin-top: 1.25rem; }
  .sect1 { padding: 0 !important; }
  .sect1 + .sect1 { border: 0; }
  #footer { background: none; }
  #footer-text { color: rgba(0, 0, 0, 0.6); font-size: 0.9em; } }
@media amzn-kf8 { #header, #content, #footnotes, #footer { padding: 0; } }
.dedication {font-size: 0.8rem; }
.dedication p {margin-bottom: 0; }

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body id="parallel-reading" class="book">
<div id="header">
<h1>Параллельное чтение данных в СУБД Firebird</h1>
<div class="details">
<span id="author" class="author">Симонов Денис, Влад Хорсун</span><br>
<span id="revnumber">version 1.0 от 03.12.2023</span>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="openblock dedication">
<div class="content">
<div class="paragraph">
<p>Этот материал был создан при поддержке и спонсорстве компании <a href="https://www.ibase.ru">iBase.ru</a>, которая разрабатывает  инструменты Firebird SQL для предприятий и предоставляет сервис технической поддержки для Firebird SQL.</p>
</div>
<div class="paragraph">
<p>Материал выпущен под лицензией Public Documentation License <a href="https://www.firebirdsql.org/file/documentation/html/en/licenses/pdl/public-documentation-license.html" class="bare">https://www.firebirdsql.org/file/documentation/html/en/licenses/pdl/public-documentation-license.html</a></p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_предисловие"><a class="anchor" href="#_предисловие"></a>Предисловие</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В Firebird 5.0 появилась возможность использовать параллелизм при создании резервной копии с помощью утилиты <code>gbak</code>.
Надо отметить, что первоначально эта функция появилась в HQbird 2.5, и уже после обкатке её реальными заказчиками была портирована в Firebird 5.0.</p>
</div>
<div class="paragraph">
<p>В этой статье мы познакомимся с некоторыми механизмами, которые используется при параллельном создании резервных копий внутри утилиты <code>gbak</code>,
а также покажем как их можно использовать в ваших приложениях для параллельного чтения данных.</p>
</div>
<div class="paragraph">
<p>Важно отметить, что здесь идёт речь не о параллельном сканировании таблиц внутри движка Firebird при выполнении SQL запросов, а чтении данных внутри вашего приложения
параллельными потоками.</p>
</div>
<div class="paragraph">
<p>Для демонстрации параллельного чтения данных из СУБД Firebird я написал простенькую утилиту, которые экспортирует данные из одной или нескольких таблиц в формат CSV.
Её описание и сходный код можно найти по адресу <a href="https://github.com/IBSurgeon/FBCSVExport.git" class="bare">https://github.com/IBSurgeon/FBCSVExport.git</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_организация_параллельного_чтения"><a class="anchor" href="#_организация_параллельного_чтения"></a>Организация параллельного чтения</h2>
<div class="sectionbody">
<div class="paragraph">
<p>И так, давайте подумаем как читать данные из нескольких таблиц параллельно. Для начала надо отметить, что Firebird, позволяет выполнять запросы параллельно только если каждый из запросов будет выполняться в отдельном соединении.</p>
</div>
<div class="paragraph">
<p>Для этой цели необходимо сделать пул рабочих потоков. Основной поток приложения
также является рабочим потоком, поэтому количество дополнительных рабочих потоков должно быть равно N - 1, где N - количество параллельных обработчиков. Каждый рабочий поток будет работать с собственным соединением и транзакцией.</p>
</div>
<div class="paragraph">
<p>И тут возникает первая проблема, а как обеспечить согласованность прочитанных данных?</p>
</div>
<div class="sect2">
<h3 id="_согласованное_чтение_данных"><a class="anchor" href="#_согласованное_чтение_данных"></a>Согласованное чтение данных</h3>
<div class="paragraph">
<p>Поскольку каждый рабочий поток использует собственное соединение и собственную транзакцию, то возникает проблема несогласованного чтения - если таблица параллельно меняется, то прочитанные данные могут быть несогласованными. В однопоточном режиме <code>gbak</code> использовал транзакцию с режимом изолированности SNAPSHOT, что позволяло читать согласованную информацию, на начало старта SNAPSHOT транзакции. Но здесь у нас несколько транзакций и необходимо, чтобы они видели один и тот же "снимок", для того чтобы они читали одни и те же неизменные данные.</p>
</div>
<div class="paragraph">
<p>Механизм создания общего снимка для разных транзакций с режимом изолированности SNAPSHOT появился в Firebird 4.0 (первоначально HQBird 2.5, но в Firebird 4.0/HQBird 4.0 он более простая и эффективная). Для создания общего снимка существует два способа:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Через SQL.</p>
<div class="ulist">
<ul>
<li>
<p>получаем номер моментального снимка из главной транзакции, то есть транзакции с которой работает основной рабочий поток.</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT RDB$GET_CONTEXT('SYSTEM', 'SNAPSHOT_NUMBER') FROM RDB$DATABASE</code></pre>
</div>
</div>
</li>
<li>
<p>стартуем другие транзакции запросом:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SET TRANSACTION SNAPSHOT AT NUMBER snapshot_number</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>где `snapshot_number` номер моментального снимка.</pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Через API.</p>
<div class="ulist">
<ul>
<li>
<p>получить номер моментального снимка из главной транзакции, то есть транзакции с которой работает основной рабочий поток, используя функцию
<code>isc_transaction_info</code> или <code>ITransaction.getInfo</code> с тегом <code>fb_info_tra_snapshot_number</code>;</p>
</li>
<li>
<p>стартуем другие транзакции, передавая туда номер снимка с помощью тега <code>isc_tpb_at_snapshot_number</code>.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><code>CSVExport</code> так же как и <code>gbak</code> использует второй подход. Эти подходы можно комбинировать, например получив номер моментального снимка запросом, но передавая этот номер
для старта других транзакций с помощью API или наоборот.</p>
</div>
<div class="paragraph">
<p>В <code>CSVExport</code> получение номера моментального снимка реализовано следующим образом:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">ISC_INT64 getSnapshotNumber(Firebird::ThrowStatusWrapper* status, Firebird::ITransaction* tra)
{
    ISC_INT64 ret = 0;
    unsigned char in_buf[] = { fb_info_tra_snapshot_number, isc_info_end };
    unsigned char out_buf[16] = { 0 };

    tra-&gt;getInfo(status, sizeof(in_buf), in_buf, sizeof(out_buf), out_buf);

    unsigned char* p = out_buf, * e = out_buf + sizeof(out_buf);
    while (p &lt; e)
    {
        short len = 0;
        switch (*p++)
        {
        case isc_info_error:
        case isc_info_end:
            p = e;
            break;

        case fb_info_tra_snapshot_number:
            len = static_cast&lt;short&gt;(isc_vax_integer(reinterpret_cast&lt;char*&gt;(p), 2));
            p += 2;
            ret = isc_portable_integer(p, len);
            p += len;
            break;
        }
    }
    return ret;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>А старт транзакции с полученным номером моментального снимка так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">Firebird::AutoDispose&lt;Firebird::IXpbBuilder&gt; tpbWorkerBuilder(fbUtil-&gt;getXpbBuilder(&amp;status, Firebird::IXpbBuilder::TPB, nullptr, 0));
tpbWorkerBuilder-&gt;insertTag(&amp;status, isc_tpb_concurrency);
tpbWorkerBuilder-&gt;insertBigInt(&amp;status, isc_tpb_at_snapshot_number, snapshotNumber);

Firebird::AutoRelease&lt;Firebird::ITransaction&gt; workerTra(
    workerAtt-&gt;startTransaction(
        &amp;status,
        tpbWorkerBuilder-&gt;getBufferLength(&amp;status),
        tpbWorkerBuilder-&gt;getBuffer(&amp;status)
    )
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Теперь данные прочитанные из разных соединений будут согласованными, можно
распределять нагрузку по рабочим потокам.</p>
</div>
<div class="paragraph">
<p>Как именно распределить нагрузку между рабочими потоками? В случае полного экспорта таблиц или резервной копии самым простым вариантом
является - один рабочий поток на одну таблицу. Но при таком подходе есть одна проблема: а что если у нас много маленьких и одна большая таблица или вообще таблица всего одна и она огромная?
В этом случае какому-то потоку достанется большая таблица, а остальные потоки будут простаивать. Для того чтобы этого не происходило необходимо обрабатывать большую таблицу по частям.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Дальнейшие рассуждения касаются только полного чтения таблиц, если вы хотите организовать параллельное чтение из некоторого запроса (представления),
то вам необходимо продумать как разбивать этот запрос на части самостоятельно.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_разбиение_большой_таблицы_на_части"><a class="anchor" href="#_разбиение_большой_таблицы_на_части"></a>Разбиение большой таблицы на части</h3>
<div class="paragraph">
<p>Допустим у нас всего одна большая таблица, которую хотим прочитать целиком и как можно быстрее.
Предлагается разбить её на несколько частей и каждую часть читать из своего
потока независимо. Каждый поток должен иметь свой коннект с БД.</p>
</div>
<div class="paragraph">
<p>В этом случае возникают следующие вопросы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>на сколько частей разбить таблицу?</p>
</li>
<li>
<p>как это лучше сделать?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ответим на эти вопросы по порядку.</p>
</div>
<div class="sect3">
<h4 id="_на_сколько_частей_разбить_таблицу"><a class="anchor" href="#_на_сколько_частей_разбить_таблицу"></a>На сколько частей разбить таблицу</h4>
<div class="paragraph">
<p>Для начала предположим идеальный вариант&#8201;&#8212;&#8201;сервер и клиент больше ничем не заняты,
то есть все CPU полностью в нашем распоряжении. Тогда я бы рекомендовал:</p>
</div>
<div class="paragraph">
<p>а) взять за максимальное количество частей двойное количество ядер на сервере.
Обычно рекомендуется разбивать подобные параллельные задачи согласно количеству ядер,
но мы точно знаем, что у нас будут задержки связанные с IO, поэтому можем себе
позволить некоторое превышение. Более точно определить может только практика.</p>
</div>
<div class="paragraph">
<p>б) учитывать количество ядер на клиенте: если на сервере их сильно больше (обычная ситуация),
то возможно будет иметь смысл сильнее ограничить количество частей разбиения, чтобы не
перегружать клиента (он всё равно больше не сможет обработать, а расходы на переключение
потоков никуда не денутся). Точнее можно будет решить, наблюдая за загрузкой CPU клиента и
сервера&#8201;&#8212;&#8201;если на клиенте 100%, а на сервере заметно меньше, то имеет смысл уменьшить
количество частей.</p>
</div>
<div class="paragraph">
<p>в) если клиент и сервер&#8201;&#8212;&#8201;один и тот же хост, то см. (а)</p>
</div>
<div class="paragraph">
<p>Если клиент и/или сервер заняты чем-то ещё, то возможно придётся ещё уменьшить
количество частей. Так же на это может повлиять способность дисков на сервере обрабатывать
множество IO запросов одновременно (наблюдать за размером очереди и временем отклика).</p>
</div>
</div>
<div class="sect3">
<h4 id="_как_лучше_разбить_таблицу_на_части"><a class="anchor" href="#_как_лучше_разбить_таблицу_на_части"></a>Как лучше разбить таблицу на части</h4>
<div class="paragraph">
<p>Для любой параллельной обработки важно обеспечить равномерное распределение заданий по
обработчикам и свести к минимуму их взаимную синхронизацию. Причём нужно помнить, что
синхронизация обработчиков может происходить как на стороне сервера, так и на стороне
клиента. Например&#8201;&#8212;&#8201;не стоит нескольким обработчикам использовать один и тот же коннект
к БД. Менее очевидный пример: плохо, если разные обработчики будут читать записи с одних
и тех же страниц БД. Например, когда два обработчика читают чётные и нечётные записи
соответственно&#8201;&#8212;&#8201;совсем не эффективно. Синхронизация на клиенте может возникнуть при
раздаче заданий, при обработке полученных данных (при выделение памяти под результаты) и так далее.</p>
</div>
<div class="paragraph">
<p>Для "честного" разбиения одна из проблем в том, что клиенту не известно как именно
распределены записи по страницам (и по ключам индексов), сколько вообще есть записей (для
больших таблиц дорого считать заранее), да и сколько есть страниц&#8201;&#8212;&#8201;тоже дорого посчитать.
Серверу это обычно тоже не известно.</p>
</div>
<div class="paragraph">
<p>Ниже описано как это делает <code>gbak</code>.</p>
</div>
<div class="paragraph">
<p>В <code>gbak</code> единицей работы является набор записей со страниц данных (DP), принадлежащих одной
и той же странице указателей (pointer page, или PP). Это, с одной стороны, достаточно большое
количество записей, чтобы обеспечить обработчик работой без необходимости часто просить новый кусок данных
(синхронизация). С другой стороны, даже если такие наборы записей будут иметь не очень
одинаковый размер, их (наборов) количество позволит относительно равномерно загрузить работой все
обработчики. То есть вполне возможны случаи, когда один обработчик прочитает N записей с одной PP, а
другой&#8201;&#8212;&#8201;M записей, и M будет достаточно отличаться от N. Но это не проблема. Такой подход не идеален,
но он весьма прост в реализации и обычно достаточно эффективен, по крайней мере на больших
таблицах&#8201;&#8212;&#8201;с десятками или сотнями (и больше) PP.</p>
</div>
<div class="paragraph">
<p>Теперь необходимо получить количество PP (Pointer Pages) для заданной таблицы. Это довольно легко,
а главное быстро, можно вычислить из таблицы <code>RDB$PAGES</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>SELECT RDB$PAGE_SEQUENCE
FROM RDB$PAGES
WHERE RDB$RELATION_ID = ? AND RDB$PAGE_TYPE = 4
ORDER BY RDB$PAGE_SEQUENCE DESC ROWS 1</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Далее можно было бы просто поделить количество PP на количество обработчиков, и выдать каждому свой
кусок. Но, как я писал выше, нет никакой гарантии, что такие "большие" куски будут означать
одинаковый объём работы. Нам же не интересно наблюдать как 15 обработчиков закончили свою работу
и простаивают, а 16-ый долго читает свои 100500 записей.</p>
</div>
<div class="paragraph">
<p>Поэтому в <code>gbak</code> это сделано иначе. Там есть координатор работы, который выдаёт каждому обработчику
по 1-ой PP за раз. Координатор знает сколько PP есть всего и сколько уже выдано в работу. Когда
обработчик прочитает свои записи, он обращается к координатору за новым номером PP. Это продолжается
до тех пор, пока не закончатся PP и пока есть работающие обработчики. Конечно, такое взаимодействие
обработчиков с координатором требует синхронизации. Опыт показывает, что объём работы, заданный
одной PP, позволяет не синхронизироваться слишком часто. Такой подход позволяет достаточно равномерно
загрузить работой все обработчики (а значит и ядра CPU) независимо от реального количества записей,
принадлежащих каждой PP.</p>
</div>
<div class="paragraph">
<p>Как же обработчик читает записи со своей PP? Для этого начиная с Firebird 4.0 (впервые появилось в HQBird 2.5) есть
встроенная функция <code>MAKE_DBKEY()</code>. С её помощью можно получить <code>RDB$DB_KEY</code> (физический номер записи) для первой записи на указанной PP.
И с помощью таких <code>RDB$DB_KEY</code> и осуществляется отбор нужных записей:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>SELECT *
FROM relation
WHERE RDB$DB_KEY &gt;= MAKE_DBKEY(:rel_id, 0, 0, :loPP)
    AND RDB$DB_KEY &lt; MAKE_DBKEY(:rel_id, 0, 0, :hiPP)</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Например, если задать loPP = 0 и hiPP = 1, то будут прочитаны все записи с PP = 0, и только из неё.</p>
</div>
<div class="paragraph">
<p>Теперь, когда есть представление о том как работает <code>gbak</code> можно перейти к описанию реализации утилиты <code>CSVExport</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_реализация_утилиты_csvexport"><a class="anchor" href="#_реализация_утилиты_csvexport"></a>Реализация утилиты <code>CSVExport</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Утилита <code>CSVExport</code> предназначена для экспорта данных из таблиц БД Firebird в формат CSV.</p>
</div>
<div class="paragraph">
<p>Каждая таблица экспортируется в файл с именем <code>&lt;tablename&gt;.csv</code>. В обычном (однопоточном режиме)
данные из таблиц экспортируется последовательно в алфавитном порядке имени таблиц.</p>
</div>
<div class="paragraph">
<p>В параллельном режиме, таблицы экспортируются параллельно, каждая таблица в отдельном потоке. Если
таблица очень большая, то она разбивается на части, и каждая часть экспортируется в отдельном потоке.
Для каждой части большой таблицы создаётся отдельный файл с именем <code>&lt;tablename&gt;.csv.partN</code>, где N - номер части.
Когда все части большой таблицы экспортированы, файлы частей сливаются в общий файл с именем <code>&lt;tablename&gt;.csv</code>.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы указать какие именно таблицы будут экспортированы используется регулярное выражение.
Возможен экспорт только обычных таблиц (системные таблицы, GTT, представления, внешние таблицы не поддерживаются).
Регулярные выражения должны быть в SQL синтаксисе, то есть такие, которые используются в предикате <code>SIMILAR TO</code>.</p>
</div>
<div class="paragraph">
<p>Для отбора списка экспортируемых таблиц, а также списка их PP в многопоточном режиме я использую следующий запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT
    R.RDB$RELATION_ID AS RELATION_ID,
    TRIM(R.RDB$RELATION_NAME) AS RELATION_NAME,
    P.RDB$PAGE_SEQUENCE AS PAGE_SEQUENCE,
    COUNT(P.RDB$PAGE_SEQUENCE) OVER(PARTITION BY R.RDB$RELATION_NAME) AS PP_CNT
FROM RDB$RELATIONS R
JOIN RDB$PAGES P ON P.RDB$RELATION_ID = R.RDB$RELATION_ID
WHERE R.RDB$SYSTEM_FLAG = 0 AND
      R.RDB$RELATION_TYPE = 0 AND
      P.RDB$PAGE_TYPE = 4 AND
      TRIM(R.RDB$RELATION_NAME) SIMILAR TO CAST(? AS VARCHAR(8191))
ORDER BY R.RDB$RELATION_NAME, P.RDB$PAGE_SEQUENCE</code></pre>
</div>
</div>
<div class="paragraph">
<p>В однопоточном режиме этот запрос можно упростить до</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT
    R.RDB$RELATION_ID AS RELATION_ID,
    TRIM(R.RDB$RELATION_NAME) AS RELATION_NAME,
    0 AS PAGE_SEQUENCE,
    1 AS PP_CNT
FROM RDB$RELATIONS R
WHERE R.RDB$SYSTEM_FLAG = 0 AND
      R.RDB$RELATION_TYPE = 0 AND
      TRIM(R.RDB$RELATION_NAME) SIMILAR TO CAST(? AS VARCHAR(8191))
ORDER BY R.RDB$RELATION_NAME</code></pre>
</div>
</div>
<div class="paragraph">
<p>В однопоточном режиме значения полей <code>PAGE_SEQUENCE</code> и <code>PP_CNT</code> не используются, они добавлены в запрос с целью унификации выходных сообщений.</p>
</div>
<div class="paragraph">
<p>Результат этого запроса складывается в вектор структур:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">struct TableDesc
{
    TableDesc() = default;
    TableDesc(const OutputRecord&amp; rec)
        : releation_id(rec-&gt;releation_id)
        , relation_name(rec-&gt;relation_name.str, rec-&gt;relation_name.length)
        , page_sequence(rec-&gt;page_sequence)
        , pp_cnt(rec-&gt;pp_cnt)
    {}

    short releation_id;
    std::string relation_name;
    int32_t page_sequence;
    int64_t pp_cnt;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>Этот вектор заполняется при помощи функции объявленной как:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">std::vector&lt;TableDesc&gt; getTablesDesc(
    Firebird::ThrowStatusWrapper* status,
    Firebird::IAttachment* att,
    Firebird::ITransaction* tra,
    unsigned int sqlDialect,
    const std::string&amp; tableIncludeFilter,
    bool singleWorker = true);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Последний параметр <code>singleWorker</code> переключает режим заполнения <code>std::vector&lt;TableDesc&gt;</code>, если
<code>singleWorker = true</code>, то используется запрос для однопоточного режима, если <code>singleWorker = false</code>, то
используется более дорогой и сложный запрос для многопоточного режима. Саму реализацию я не буду приводить,
она довольно проста, и вы можете посмотреть её в исходном коде проекта.</p>
</div>
<div class="paragraph">
<p>Для экспорта таблицы в формат CSV разработан класс <code>CSVExportTable</code>, который содержит следующие методы:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">    void prepare(Firebird::ThrowStatusWrapper* status, const std::string&amp; tableName,
                 unsigned int sqlDialect, bool withDbkeyFilter = false);

    void printHeader(Firebird::ThrowStatusWrapper* status, csv::CSVFile&amp; csv);

    void printData(Firebird::ThrowStatusWrapper* status, csv::CSVFile&amp; csv, int64_t ppNum = 0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Метод <code>prepare</code> предназначен для построения и подготовки запроса, который используется для экспорта таблицы
в формат CSV. Внутренний запрос строится по разному в зависимости от параметра <code>withDbkeyFilter</code>.
Если <code>withDbkeyFilter = true</code>, то запрос строится с фильтрацией по диапазону <code>RDB$DB_KEY</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT *
FROM tableName
WHERE RDB$DB_KEY &gt;= MAKE_DBKEY('tableName', 0, 0, ?)
  AND RDB$DB_KEY &lt; MAKE_DBKEY('tableName', 0, 0, ?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>в противном случае используется упрощённый запрос:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sql hljs" data-lang="sql">SELECT *
FROM tableName</code></pre>
</div>
</div>
<div class="paragraph">
<p>Значение параметра <code>withDbkeyFilter</code> устанавливается в <code>true</code>, если используется многопоточный режим, и таблица является большой.
Считаем таблицу большой, если <code>pp_cnt &gt; 1</code>.</p>
</div>
<div class="paragraph">
<p>Метод <code>printHeader</code> предназначен для печати заголовка CSV файла (имён столбцов таблицы).</p>
</div>
<div class="paragraph">
<p>Метод <code>printData</code> печатает данные таблицы в CSV файл c PP страницы с номером <code>ppNum</code>, если запрос был подготовлен с использованием фильтра
по диапазону <code>RDB$DB_KEY</code>, и всех данных таблицы в противном случае.</p>
</div>
<div class="paragraph">
<p>Теперь посмотрим фрагмент кода для работы в однопоточном режиме</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">...

// Открываем главное соединение
Firebird::AutoRelease&lt;Firebird::IAttachment&gt; att(
    provider-&gt;attachDatabase(
        &amp;status,
        m_database.c_str(),
        dbpLength,
        dpb
    )
);

// Стартуем главную транзакцию в режиме изолированности SNAPSHOT
Firebird::AutoDispose&lt;Firebird::IXpbBuilder&gt; tpbBuilder(fbUtil-&gt;getXpbBuilder(&amp;status, Firebird::IXpbBuilder::TPB, nullptr, 0));
tpbBuilder-&gt;insertTag(&amp;status, isc_tpb_concurrency);

Firebird::AutoRelease&lt;Firebird::ITransaction&gt; tra(
    att-&gt;startTransaction(
        &amp;status,
        tpbBuilder-&gt;getBufferLength(&amp;status),
        tpbBuilder-&gt;getBuffer(&amp;status)
    )
);
// Получаем список таблиц по регулярному выражению в m_filter.
// m_parallel задаёт количество параллельных потоков, когда она равна 1,
// то используется упрощённый запрос для получения списка таблиц,
// в противном случае, для каждой таблицы формируется список PP и их количество.
auto tables = getTablesDesc(&amp;status, att, tra, m_sqlDialect, m_filter, m_parallel == 1);

if (m_parallel == 1) {
    FBExport::CSVExportTable csvExport(att, tra, fb_master);
    for (const auto&amp; tableDesc : tables) {
        // здесь нет смысла использовать фильтр по диапазону RDB$DB_KEY
        csvExport.prepare(&amp;status, tableDesc.relation_name, m_sqlDialect, false);
        const std::string fileName = tableDesc.relation_name + ".csv";
        csv::CSVFile csv(m_outputDir / fileName);
        if (m_printHeader) {
            csvExport.printHeader(&amp;status, csv);
        }
        csvExport.printData(&amp;status, csv);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Здесь всё довольно просто и не требует дополнительных пояснений, поэтому перейдем к многопоточной части.</p>
</div>
<div class="paragraph">
<p>Для того, чтобы экспорт происходил в многопоточном режиме, необходимо создать дополнительные <code>m_parallel - 1</code> рабочих потоков.
Почему количество дополнительных потоков на 1 меньше? Да потому что основной поток, тоже будет заниматься экспортом данных и он
является равноправным с дополнительными потоками. Вынесем общую часть основного и дополнительного потока в отдельную функцию:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">void ExportApp::exportByTableDesc(Firebird::ThrowStatusWrapper* status, FBExport::CSVExportTable&amp; csvExport, const TableDesc&amp; tableDesc)
{
    // Если в tableDesc pp_cnt &gt; 1, то она описывает только часть таблицы, и необходимо построить
    // запрос с использованием фильтра по диапазону RDB$DB_KEY.
    bool withDbKeyFilter = tableDesc.pp_cnt &gt; 1;
    csvExport.prepare(status, tableDesc.relation_name, m_sqlDialect, withDbKeyFilter);
    std::string fileName = tableDesc.relation_name + ".csv";
    // Если это не первая часть таблицы, то записываем эту часть в файл &lt;tableName&gt;.csv.part&lt;N&gt;, где
    // N - номер PP. Позднее части таблицы будут соединены в единый файл &lt;tableName&gt;.csv
    if (tableDesc.page_sequence &gt; 0) {
        fileName += ".part_" + std::to_string(tableDesc.page_sequence);
    }
    csv::CSVFile csv(m_outputDir / fileName);
    // Заголовок CSV файла нужно печатать только в первую часть таблицы.
    if (tableDesc.page_sequence == 0 &amp;&amp; m_printHeader) {
        csvExport.printHeader(status, csv);
    }
    csvExport.printData(status, csv, tableDesc.page_sequence);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Описание таблиц или её частей расположено в общем векторе со структурами <code>TableDesc</code>. Из этого вектора каждый рабочий поток берёт таблицу или очередную часть
Для предотвращения data races необходимо синхронизация доступа к общему ресурсу. Но сам <code>std::vector&lt;TableDesc&gt;</code> не меняется, поэтому можно синхронизировать только общую переменную, которая является индексом в этом векторе. Это легко сделать используя в качестве такой переменной <code>std::atomic&lt;size_t&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">if (m_parallel == 1) {
    ...
}
else {
    // Определяем количество дополнительных рабочих потоков
    const auto workerCount = m_parallel - 1;

    // Получаем номер моментального снимка из основной транзакции
    auto snapshotNumber = getSnapshotNumber(&amp;status, tra);
    // переменная для сохранения исключения внутри потока
    std::exception_ptr exceptionPointer = nullptr;
    std::mutex m;
    // атомарный счётчик
    // является индексом очередной таблицы или её части
    std::atomic&lt;size_t&gt; counter = 0;
    // пул рабочих потоков
    std::vector&lt;std::thread&gt; thread_pool;
    thread_pool.reserve(workerCount);
    for (int i = 0; i &lt; workerCount; i++) {
        // для каждого потока создаём своё соединение
        Firebird::AutoRelease&lt;Firebird::IAttachment&gt; workerAtt(
            provider-&gt;attachDatabase(
                &amp;status,
                m_database.c_str(),
                dbpLength,
                dpb
            )
        );
        // и свою транзакцию в которую передаём номер моментального снимка
        // для создания общего снимка
        Firebird::AutoDispose&lt;Firebird::IXpbBuilder&gt; tpbWorkerBuilder(fbUtil-&gt;getXpbBuilder(&amp;status, Firebird::IXpbBuilder::TPB, nullptr, 0));
        tpbWorkerBuilder-&gt;insertTag(&amp;status, isc_tpb_concurrency);
        tpbWorkerBuilder-&gt;insertBigInt(&amp;status, isc_tpb_at_snapshot_number, snapshotNumber);

        Firebird::AutoRelease&lt;Firebird::ITransaction&gt; workerTra(
            workerAtt-&gt;startTransaction(
                &amp;status,
                tpbWorkerBuilder-&gt;getBufferLength(&amp;status),
                tpbWorkerBuilder-&gt;getBuffer(&amp;status)
            )
        );
        // создаём поток
        std::thread t([att = std::move(workerAtt), tra = std::move(workerTra), this,
                       &amp;m, &amp;tables, &amp;counter, &amp;exceptionPointer]() mutable {

            Firebird::ThrowStatusWrapper status(fb_master-&gt;getStatus());
            try {
                FBExport::CSVExportTable csvExport(att, tra, fb_master);
                while (true) {
                    // увеличиваем атомарный счётчик
                    size_t localCounter = counter++;
                    // если таблицы или их части закончились выходим
                    // из бесконечного цикла и завершаем поток
                    if (localCounter &gt;= tables.size())
                        break;
                    // получаем описание таблицы или её части
                    const auto&amp; tableDesc = tables[localCounter];
                    // и делаем экспорт
                    exportByTableDesc(&amp;status, csvExport, tableDesc);
                }
                if (tra) {
                    tra-&gt;commit(&amp;status);
                    tra.release();
                }

                if (att) {
                    att-&gt;detach(&amp;status);
                    att.release();
                }
            }
            catch (...) {
                // если возникло исключение, то сохраняем его для
                // последующего выброса в основном потоке
                std::unique_lock&lt;std::mutex&gt; lock(m);
                exceptionPointer = std::current_exception();
            }
        });
        thread_pool.push_back(std::move(t));
    }

    // экспорт в основном потоке
    FBExport::CSVExportTable csvExport(att, tra, fb_master);
    while (true) {
        // увеличиваем атомарный счётчик
        size_t localCounter = counter++;
        if (localCounter &gt;= tables.size())
            break;
        // если таблицы или их части закончились выходим
         // из бесконечного цикла
        const auto&amp; tableDesc = tables[localCounter];
        exportByTableDesc(&amp;status, csvExport, tableDesc);
    }
    // ждём завершения рабочих потоков
    for (auto&amp; th : thread_pool) {
        th.join();
    }
    // если в рабочих потоках было исключение выбрасываем его повторно
    if (exceptionPointer) {
        std::rethrow_exception(exceptionPointer);
    }
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Осталось соединить файлы, которые были созданы для частей таблиц в единой файл для каждой из этих таблиц.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cpp hljs" data-lang="cpp">for (size_t i = 0; i &lt; tables.size(); i++) {
    const auto&amp; tableDesc = tables[i];
    // если количество PP больше 1,
    // то таблица большая и для неё было несколько частей
    if (tableDesc.pp_cnt &gt; 1) {
        // основной файл для таблицы
        std::string fileName = tableDesc.relation_name + ".csv";
        std::ofstream ofile(m_outputDir / fileName, std::ios::out | std::ios::app);
        i++;
        for (int64_t j = 1; j &lt; tableDesc.pp_cnt; j++, i++) {
            // файлы частей таблицы
            std::string partFileName = fileName + ".part_" + std::to_string(j);
            auto partFilePath = m_outputDir / partFileName;
            std::ifstream ifile(partFilePath, std::ios::in);
            ofile &lt;&lt; ifile.rdbuf();
            ifile.close();
            fs::remove(partFilePath);
        }
        ofile.close();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ну вот и всё пришло время померить производительность нашей утилиты в однопоточном и многопоточном режиме.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_бенчмарк_утилиты_csvexport"><a class="anchor" href="#_бенчмарк_утилиты_csvexport"></a>Бенчмарк утилиты <code>CSVExport</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Для начала посмотрим на результаты сравнения многопоточного и однопоточного режима экспорта на моём домашнем не самом современном компьютере.</p>
</div>
<div class="sect2">
<h3 id="_windows"><a class="anchor" href="#_windows"></a>Windows</h3>
<div class="ulist">
<ul>
<li>
<p>Операционная система: Windows 10 x64.</p>
</li>
<li>
<p>Процессор: Intel Core i3 8100, 4 ядра, 4 потока.</p>
</li>
<li>
<p>Память: 16 Гб</p>
</li>
<li>
<p>Дисковая подсистема: NVME SSD (база данных), SATA SSD (папка для размещения CSV файлов).</p>
</li>
<li>
<p>Firebird 4.0.4 x64</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Результаты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">CSVExport.exe -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=1 \
  -d inet://localhost:3054/horses -u SYSDBA -p masterkey --charset=WIN1251 -o ./single

Elapsed time in milliseconds parallel_part: 35894 ms
Elapsed time in milliseconds: 36317 ms

CSVExport.exe -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=4 \
  -d inet://localhost:3054/horses -u SYSDBA -p masterkey --charset=WIN1251 -o ./multi

Elapsed time in milliseconds parallel_part: 19259 ms
Elapsed time in milliseconds: 20760 ms

CSVExport.exe -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=4 \
  -d inet://localhost:3054/horses -u SYSDBA -p masterkey --charset=WIN1251 -o ./multi

Elapsed time in milliseconds parallel_part: 19600 ms
Elapsed time in milliseconds: 21137 ms</code></pre>
</div>
</div>
<div class="paragraph">
<p>Из результата тестирования видно, что при использовании двух потоков, ускорении составило 1.8 раза, что является хорошим результатом.
Но параллельное выполнение экспорта в 4 потоках, тоже дало ускорение в 1.8 раза. Почему не в 3-4?
Дело в том, что сервер Firebird и утилита экспорта запущены на одном и том же компьютере, у которого всего 4 ядра.
Таким образом сам сервер Firebird, использует 4 потока для чтения таблицы и утилита <code>CSVExport</code>, тоже использует 4 потока.
Очевидно, что в таком случае довольно затруднительно получить ускорение более чем в 2 раза.
Поэтому попробуем на другом железе, где количество ядер существенно больше.</p>
</div>
</div>
<div class="sect2">
<h3 id="_linux"><a class="anchor" href="#_linux"></a>Linux</h3>
<div class="ulist">
<ul>
<li>
<p>Операционная система: CentOS 8.</p>
</li>
<li>
<p>Процессор: 2 процессора Intel Xeon E5-2603 v4, всего 12 ядер, 12 потоков.</p>
</li>
<li>
<p>Память: 32 Гб</p>
</li>
<li>
<p>Дисковая подсистема: SAS HDD (RAID 10)</p>
</li>
<li>
<p>Firebird 4.0.4 x64</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Результаты:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">[denis@copyserver build]$ ./CSVExport -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=1 \
  -d inet://localhost/horses -u SYSDBA -p masterkey --charset=UTF8 -o ./single

Elapsed time in milliseconds parallel_part: 57547 ms
Elapsed time in milliseconds: 57595 ms

[denis@copyserver build]$ ./CSVExport -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=4 \
  -d inet://localhost/horses -u SYSDBA -p masterkey --charset=UTF8 -o ./multi

Elapsed time in milliseconds parallel_part: 17755 ms
Elapsed time in milliseconds: 18148 ms

[denis@copyserver build]$ ./CSVExport -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=6 \
  -d inet://localhost/horses -u SYSDBA -p masterkey --charset=UTF8 -o ./multi

Elapsed time in milliseconds parallel_part: 13243 ms
Elapsed time in milliseconds: 13624 ms

[denis@copyserver build]$ ./CSVExport -H --table-filter="COLOR|BREED|HORSE|COVER|MEASURE|LAB_LINE|SEX" --parallel=12 \
  -d inet://localhost/horses -u SYSDBA -p masterkey --charset=UTF8 -o ./multi

Elapsed time in milliseconds parallel_part: 12712 ms
Elapsed time in milliseconds: 13140 ms</code></pre>
</div>
</div>
<div class="paragraph">
<p>В данном случае оптимальном числом потоков для экспорта является 6 (6 потоков для Firebird и 6 потоков для утилиты <code>CSVExport</code>).
При этом удалось получить ускорение в 5 раз, что говорит о достаточно хорошей масштабируемости. Хотелось бы отметить, что для проверки
на Linux и Windows использовались идентичные базы данных почти одинакового размера. В одном потоке, на Windows экспорт прошёл почти в 2 раза
быстрее, из-за более быстрой дисковой подсистемы. Всё таки NVME диски намного быстрее SAS дисков объединённых в RAID.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_заключение"><a class="anchor" href="#_заключение"></a>Заключение</h2>
<div class="sectionbody">
<div class="paragraph">
<p>В этой статье мы научились эффективно использовать читать данные из таблиц СУБД Firebird используя параллелизм, и что самое согласовано читать их.
Кроме того, был показан пример как можно использовать некоторые возможности СУБД Firebird для организации такого тения в своих утилитах.</p>
</div>
<div class="paragraph">
<p>Огромное спасибо Владиславу Хорсуну, автору многопоточного <code>gbak</code> в Firebird 5.0 и HQbird, за подробное объяснение принципов работы
параллельного резервного копирования. Без него этой статьи не было бы.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0 от 03.12.2023<br>
Last updated 2023-12-05 11:49:54 +0300
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>